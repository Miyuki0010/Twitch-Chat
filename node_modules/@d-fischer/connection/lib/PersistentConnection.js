"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PersistentConnection = void 0;
const shared_utils_1 = require("@d-fischer/shared-utils");
const typed_event_emitter_1 = require("@d-fischer/typed-event-emitter");
class PersistentConnection extends typed_event_emitter_1.EventEmitter {
    constructor(_type, _connectionInfo, config = {}, _additionalOptions) {
        var _a;
        super();
        this._type = _type;
        this._connectionInfo = _connectionInfo;
        this._additionalOptions = _additionalOptions;
        this._retryLimit = Infinity;
        this._initialRetryLimit = 3;
        this._connecting = false;
        this._connectionRetryCount = 0;
        this.onReceive = this.registerEvent();
        this.onConnect = this.registerEvent();
        this.onDisconnect = this.registerEvent();
        this.onEnd = this.registerEvent();
        this._retryLimit = (_a = config.retryLimit) !== null && _a !== void 0 ? _a : Infinity;
        this._logger = config.logger;
    }
    get isConnected() {
        var _a, _b;
        return (_b = (_a = this._currentConnection) === null || _a === void 0 ? void 0 : _a.isConnected) !== null && _b !== void 0 ? _b : false;
    }
    get isConnecting() {
        var _a, _b;
        return (_b = (_a = this._currentConnection) === null || _a === void 0 ? void 0 : _a.isConnecting) !== null && _b !== void 0 ? _b : this._connecting;
    }
    get host() {
        return this._connectionInfo.hostName;
    }
    get port() {
        return this._connectionInfo.port;
    }
    get hasSocket() {
        var _a, _b;
        return (_b = (_a = this._currentConnection) === null || _a === void 0 ? void 0 : _a.hasSocket) !== null && _b !== void 0 ? _b : false;
    }
    sendLine(line) {
        var _a;
        (_a = this._currentConnection) === null || _a === void 0 ? void 0 : _a.sendLine(line);
    }
    async connect() {
        await this._connect(true);
    }
    async disconnect() {
        var _a;
        (_a = this._logger) === null || _a === void 0 ? void 0 : _a.trace(`PersistentConnection disconnect currentConnectionExists:${Boolean(this._currentConnection).toString()} connecting:${this._connecting.toString()}`);
        this._connecting = false;
        if (this._currentConnection) {
            const lastConnection = this._currentConnection;
            this._currentConnection = undefined;
            await lastConnection.disconnect();
        }
    }
    assumeExternalDisconnect() {
        var _a, _b;
        (_a = this._logger) === null || _a === void 0 ? void 0 : _a.trace('PersistentConnection assumeExternalDisconnect');
        (_b = this._currentConnection) === null || _b === void 0 ? void 0 : _b.assumeExternalDisconnect();
    }
    async reconnect() {
        await this._reconnect(true);
    }
    async _connect(userGenerated = false) {
        var _a, _b, _c, _d;
        (_a = this._logger) === null || _a === void 0 ? void 0 : _a.trace(`PersistentConnection connect currentConnectionExists:${Boolean(this._currentConnection).toString()} connecting:${this._connecting.toString()}`);
        if (this._currentConnection || this._connecting) {
            throw new Error('Connection already present');
        }
        this._connectionRetryCount = 0;
        this._connecting = true;
        const retryLimit = userGenerated ? this._initialRetryLimit : this._retryLimit;
        this._retryTimerGenerator = PersistentConnection._getReconnectWaitTime();
        while (this._connectionRetryCount <= retryLimit) {
            const newConnection = (this._currentConnection = new this._type(this._connectionInfo, this._logger, this._additionalOptions));
            newConnection.onReceive(line => this.emit(this.onReceive, line));
            newConnection.onConnect(() => this.emit(this.onConnect));
            newConnection.onDisconnect((manually, reason) => {
                this.emit(this.onDisconnect, manually, reason);
                if (manually) {
                    this.emit(this.onEnd, true);
                    void newConnection.disconnect();
                    if (this._currentConnection === newConnection) {
                        this._currentConnection = undefined;
                    }
                }
                else if (!this._connecting) {
                    void this._reconnect();
                }
            });
            try {
                await newConnection.connect();
                this._connecting = false;
                return;
            }
            catch (e) {
                if (!this._connecting) {
                    return;
                }
                (_b = this._logger) === null || _b === void 0 ? void 0 : _b.debug(`Connection error caught: ${e.message}`);
                if (this._connectionRetryCount >= retryLimit) {
                    break;
                }
                this._connectionRetryCount++;
                const secs = this._retryTimerGenerator.next().value;
                if (secs !== 0) {
                    (_c = this._logger) === null || _c === void 0 ? void 0 : _c.info(`Retrying in ${secs} seconds`);
                }
                await shared_utils_1.delay(secs * 1000);
                (_d = this._logger) === null || _d === void 0 ? void 0 : _d.info(userGenerated ? 'Retrying connection' : 'Trying to reconnect');
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                if (!this._connecting) {
                    return;
                }
            }
        }
        const error = new Error(`Connection failed after trying ${retryLimit} times`);
        this.emit(this.onEnd, false, error);
        if (userGenerated) {
            throw error;
        }
    }
    async _reconnect(userGenerated = false) {
        void this.disconnect().catch((e) => { var _a; return (_a = this._logger) === null || _a === void 0 ? void 0 : _a.error(`Error while disconnecting for the reconnect: ${e.message}`); });
        await this._connect(userGenerated);
    }
    // yes, this is just fibonacci with a limit
    static *_getReconnectWaitTime() {
        let current = 0;
        let next = 1;
        while (current < 120) {
            yield current;
            [current, next] = [next, current + next];
        }
        while (true) {
            yield 120;
        }
    }
}
exports.PersistentConnection = PersistentConnection;
//# sourceMappingURL=PersistentConnection.js.map