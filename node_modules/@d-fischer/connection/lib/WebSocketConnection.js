"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketConnection = void 0;
const isomorphic_ws_1 = require("@d-fischer/isomorphic-ws");
const AbstractConnection_1 = require("./AbstractConnection");
class WebSocketConnection extends AbstractConnection_1.AbstractConnection {
    constructor() {
        super(...arguments);
        this._socket = null;
    }
    get port() {
        return this._port;
    }
    get hasSocket() {
        return !!this._socket;
    }
    sendRaw(line) {
        var _a;
        (_a = this._socket) === null || _a === void 0 ? void 0 : _a.send(line);
    }
    async connect() {
        var _a;
        (_a = this._logger) === null || _a === void 0 ? void 0 : _a.trace('WebSocketConnection connect');
        await new Promise((resolve, reject) => {
            var _a;
            this._connecting = true;
            const url = `ws${this._secure ? 's' : ''}://${this._host}:${this.port}`;
            this._socket = new isomorphic_ws_1.WebSocket(url, (_a = this._additionalOptions) === null || _a === void 0 ? void 0 : _a.wsOptions);
            this._socket.onopen = () => {
                var _a;
                (_a = this._logger) === null || _a === void 0 ? void 0 : _a.trace('WebSocketConnection onOpen');
                this._connected = true;
                this._connecting = false;
                this.emit(this.onConnect);
                resolve();
            };
            this._socket.onmessage = ({ data }) => {
                this.receiveRaw(data.toString());
            };
            // The following empty error callback needs to exist so connection errors are passed down to `onclose` down below - otherwise the process just crashes instead
            this._socket.onerror = e => {
                var _a;
                (_a = this._logger) === null || _a === void 0 ? void 0 : _a.trace(`WebSocketConnection onError message:${e.message}`);
            };
            this._socket.onclose = e => {
                var _a;
                const wasConnected = this._connected;
                (_a = this._logger) === null || _a === void 0 ? void 0 : _a.trace(`WebSocketConnection onClose wasConnected:${wasConnected.toString()} wasClean:${e.wasClean.toString()}`);
                this._connected = false;
                this._connecting = false;
                if (e.wasClean) {
                    this.emit(this.onDisconnect, true);
                    this.emit(this.onEnd, true);
                }
                else {
                    const err = new Error(`[${e.code}] ${e.reason}`);
                    this.emit(this.onDisconnect, false, err);
                    this.emit(this.onEnd, false, err);
                    if (!wasConnected) {
                        reject(err);
                    }
                }
                if (this._socket) {
                    this._socket.onopen = null;
                    this._socket.onmessage = null;
                    this._socket.onerror = null;
                    this._socket.onclose = null;
                    this._socket = null;
                }
            };
        });
    }
    async disconnect() {
        var _a;
        (_a = this._logger) === null || _a === void 0 ? void 0 : _a.trace('WebSocketConnection disconnect');
        await new Promise(resolve => {
            if (this._socket) {
                const listener = this.onDisconnect(() => {
                    listener.unbind();
                    resolve();
                });
                this._socket.close();
            }
            else {
                resolve();
            }
        });
    }
}
exports.WebSocketConnection = WebSocketConnection;
//# sourceMappingURL=WebSocketConnection.js.map